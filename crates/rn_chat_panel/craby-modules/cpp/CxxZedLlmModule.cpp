// Auto generated by Craby. DO NOT EDIT.
#include "CxxZedLlmModule.hpp"
#include "cxx.h"
#include "bridging-generated.hpp"
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace zedmodules {
namespace modules {

std::string CxxZedLlmModule::dataPath = std::string();

CxxZedLlmModule::CxxZedLlmModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxZedLlmModule::kModuleName, jsInvoker) {
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::zedmodules::signals::SignalManager::getInstance();
  manager.registerDelegate(id,
    [this](const std::string& name, void* signal) {
      this->emit(name, reinterpret_cast<bridging::ZedLLMSignal*>(signal));
    }
  );
  callInvoker_ = std::move(jsInvoker);
  module_ = std::shared_ptr<craby::zedmodules::bridging::ZedLlm>(
    craby::zedmodules::bridging::createZedLlm(
      reinterpret_cast<uintptr_t>(this),
      rust::Str(dataPath.data(), dataPath.size())).into_raw(),
    [](craby::zedmodules::bridging::ZedLlm *ptr) { rust::Box<craby::zedmodules::bridging::ZedLlm>::from_raw(ptr); }
  );
  threadPool_ = std::make_shared<craby::zedmodules::utils::ThreadPool>(10);
  methodMap_["addListener"] = MethodMetadata{1, &CxxZedLlmModule::addListener};
  methodMap_["cancelRequest"] = MethodMetadata{1, &CxxZedLlmModule::cancelRequest};
  methodMap_["cancelToolCall"] = MethodMetadata{1, &CxxZedLlmModule::cancelToolCall};
  methodMap_["connectAgent"] = MethodMetadata{1, &CxxZedLlmModule::connectAgent};
  methodMap_["disconnectAgent"] = MethodMetadata{1, &CxxZedLlmModule::disconnectAgent};
  methodMap_["ensureAgentThread"] = MethodMetadata{1, &CxxZedLlmModule::ensureAgentThread};
  methodMap_["getAgentModels"] = MethodMetadata{1, &CxxZedLlmModule::getAgentModels};
  methodMap_["getAgentModes"] = MethodMetadata{1, &CxxZedLlmModule::getAgentModes};
  methodMap_["getAgentServers"] = MethodMetadata{0, &CxxZedLlmModule::getAgentServers};
  methodMap_["getDefaultModelId"] = MethodMetadata{0, &CxxZedLlmModule::getDefaultModelId};
  methodMap_["getModels"] = MethodMetadata{0, &CxxZedLlmModule::getModels};
  methodMap_["getProviders"] = MethodMetadata{0, &CxxZedLlmModule::getProviders};
  methodMap_["isAvailable"] = MethodMetadata{0, &CxxZedLlmModule::isAvailable};
  methodMap_["listAcpThreads"] = MethodMetadata{0, &CxxZedLlmModule::listAcpThreads};
  methodMap_["minimizeChatPane"] = MethodMetadata{0, &CxxZedLlmModule::minimizeChatPane};
  methodMap_["openAcpThread"] = MethodMetadata{1, &CxxZedLlmModule::openAcpThread};
  methodMap_["removeListeners"] = MethodMetadata{1, &CxxZedLlmModule::removeListeners};
  methodMap_["respondToToolAuthorization"] = MethodMetadata{2, &CxxZedLlmModule::respondToToolAuthorization};
  methodMap_["searchAcpThreads"] = MethodMetadata{1, &CxxZedLlmModule::searchAcpThreads};
  methodMap_["sendMessage"] = MethodMetadata{1, &CxxZedLlmModule::sendMessage};
  methodMap_["sendMessageToAgent"] = MethodMetadata{2, &CxxZedLlmModule::sendMessageToAgent};
  methodMap_["sendMessageToModel"] = MethodMetadata{2, &CxxZedLlmModule::sendMessageToModel};
  methodMap_["setAgentMode"] = MethodMetadata{2, &CxxZedLlmModule::setAgentMode};
  methodMap_["setAgentModel"] = MethodMetadata{2, &CxxZedLlmModule::setAgentModel};
  methodMap_["setChatPaneVisible"] = MethodMetadata{1, &CxxZedLlmModule::setChatPaneVisible};
  methodMap_["startAgentThread"] = MethodMetadata{1, &CxxZedLlmModule::startAgentThread};
  methodMap_["acpThreadsChanged"] = MethodMetadata{1, &CxxZedLlmModule::acpThreadsChanged};
  methodMap_["agentConnected"] = MethodMetadata{1, &CxxZedLlmModule::agentConnected};
  methodMap_["agentDisconnected"] = MethodMetadata{1, &CxxZedLlmModule::agentDisconnected};
  methodMap_["llmChunk"] = MethodMetadata{1, &CxxZedLlmModule::llmChunk};
  methodMap_["llmDone"] = MethodMetadata{1, &CxxZedLlmModule::llmDone};
  methodMap_["llmError"] = MethodMetadata{1, &CxxZedLlmModule::llmError};
  methodMap_["threadSnapshot"] = MethodMetadata{1, &CxxZedLlmModule::threadSnapshot};
  methodMap_["toolCallEvent"] = MethodMetadata{1, &CxxZedLlmModule::toolCallEvent};
}

CxxZedLlmModule::~CxxZedLlmModule() {
  invalidate();
}

void CxxZedLlmModule::invalidate() {
  if (invalidated_.exchange(true)) {
    return;
  }

  invalidated_.store(true);
  listenersMap_.clear();

  // Unregister from signal manager
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::zedmodules::signals::SignalManager::getInstance();
  manager.unregisterDelegate(id);

  // Shutdown thread pool
  threadPool_->shutdown();
}

void CxxZedLlmModule::emit(std::string name, bridging::ZedLLMSignal* signal) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // Prepare payload: extract from signal or use undefined
  auto payloadPtr = std::make_shared<facebook::jsi::Value>();
  
  if (signal == nullptr) {
    *payloadPtr = facebook::jsi::Value::undefined();
  } else {
    // Use shared_ptr to manage signal lifetime across async callbacks
    auto signalPtr = std::shared_ptr<bridging::ZedLLMSignal>(
      signal,
      [](bridging::ZedLLMSignal* ptr) {
        // Use Rust FFI function to drop signal memory
        if (ptr != nullptr) {
          craby::zedmodules::bridging::drop_zed_llm_signal(ptr);
        }
      }
    );

    // Extract payload using FFI function and convert to jsi::Value
    // We'll need to capture signalPtr in the lambda
    for (auto& listener : listeners) {
      try {
        callInvoker_->invokeAsync([listener, signalPtr, name](jsi::Runtime &rt) {
          jsi::Value data = jsi::Value::undefined();
          if (name == "acpThreadsChanged") {
            auto payload = craby::zedmodules::bridging::get_acp_threads_changed_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "agentConnected") {
            auto payload = craby::zedmodules::bridging::get_agent_connected_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "agentDisconnected") {
            auto payload = craby::zedmodules::bridging::get_agent_disconnected_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "llmChunk") {
            auto payload = craby::zedmodules::bridging::get_llm_chunk_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "llmDone") {
            auto payload = craby::zedmodules::bridging::get_llm_done_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "llmError") {
            auto payload = craby::zedmodules::bridging::get_llm_error_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "threadSnapshot") {
            auto payload = craby::zedmodules::bridging::get_thread_snapshot_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          } else if (name == "toolCallEvent") {
            auto payload = craby::zedmodules::bridging::get_tool_call_event_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          }
          listener->call(rt, data);
        });
      } catch (const std::exception& err) {
        // Noop
      }
    }
    return;
  }

  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, payloadPtr](jsi::Runtime &rt) {
        try {
          listener->call(rt, *payloadPtr);
        } catch (const jsi::JSError &err) {
          throw err;
        } catch (const std::exception &err) {
          throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
        }
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

jsi::Value CxxZedLlmModule::addListener(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    craby::zedmodules::bridging::addListener(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::cancelRequest(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    craby::zedmodules::bridging::cancelRequest(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::cancelToolCall(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::cancelToolCall(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::connectAgent(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::connectAgent(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::disconnectAgent(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    craby::zedmodules::bridging::disconnectAgent(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::ensureAgentThread(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::ensureAgentThread(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getAgentModels(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::getAgentModels(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getAgentModes(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::getAgentModes(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getAgentServers(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::getAgentServers(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getDefaultModelId(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::getDefaultModelId(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getModels(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::getModels(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::getProviders(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::getProviders(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::isAvailable(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::isAvailable(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::listAcpThreads(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::listAcpThreads(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::minimizeChatPane(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    craby::zedmodules::bridging::minimizeChatPane(*it_);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::openAcpThread(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::openAcpThread(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::removeListeners(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    craby::zedmodules::bridging::removeListeners(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::respondToToolAuthorization(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    auto ret = craby::zedmodules::bridging::respondToToolAuthorization(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::searchAcpThreads(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::searchAcpThreads(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::sendMessage(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::sendMessage(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::sendMessageToAgent(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    auto ret = craby::zedmodules::bridging::sendMessageToAgent(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::sendMessageToModel(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    auto ret = craby::zedmodules::bridging::sendMessageToModel(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::setAgentMode(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    auto ret = craby::zedmodules::bridging::setAgentMode(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::setAgentModel(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (2 != count) {
      throw jsi::JSError(rt, "Expected 2 arguments");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto arg1$raw = args[1].asString(rt).utf8(rt);
    auto arg1 = rust::Str(arg1$raw.data(), arg1$raw.size());
    auto ret = craby::zedmodules::bridging::setAgentModel(*it_, arg0, arg1);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::setChatPaneVisible(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<bool>(rt, args[0], callInvoker);
    craby::zedmodules::bridging::setChatPaneVisible(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::startAgentThread(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    auto ret = craby::zedmodules::bridging::startAgentThread(*it_, arg0);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::acpThreadsChanged(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "acpThreadsChanged";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::agentConnected(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "agentConnected";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::agentDisconnected(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "agentDisconnected";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::llmChunk(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "llmChunk";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::llmDone(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "llmDone";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::llmError(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "llmError";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::threadSnapshot(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "threadSnapshot";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedLlmModule::toolCallEvent(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedLlmModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "toolCallEvent";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

} // namespace modules
} // namespace zedmodules
} // namespace craby
