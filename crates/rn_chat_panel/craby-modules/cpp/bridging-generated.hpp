// Auto generated by Craby. DO NOT EDIT.
#pragma once

#include "cxx.h"
#include "ffi.rs.h"
#include <react/bridging/Bridging.h>
#include <variant>
#include <iterator>
#include <algorithm>

using namespace facebook;

namespace zedmodules {

class RustVecBuffer : public jsi::MutableBuffer {
public:
  explicit RustVecBuffer(rust::Vec<uint8_t> vec)
    : vec_(std::move(vec)) {}

  ~RustVecBuffer() override = default;

  size_t size() const override {
    return vec_.size();
  }

  uint8_t* data() override {
    return const_cast<uint8_t*>(vec_.data());
  }

private:
  rust::Vec<uint8_t> vec_;
};

} // namespace zedmodules

namespace facebook {
namespace react {

template <>
struct Bridging<std::monostate> {
  static std::monostate fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    return std::monostate{};
  }

  static jsi::Value toJs(jsi::Runtime& rt, const std::monostate& value) {
    return jsi::Value::undefined();
  }
};

template <>
struct Bridging<rust::Str> {
  static rust::Str fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::Str(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Str& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::String> {
  static rust::String fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto str = value.asString(rt).utf8(rt);
    return rust::String(str.data(), str.size());
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::String& value) {
    return react::bridging::toJs(rt, std::string(value.data(), value.size()));
  }
};

template <>
struct Bridging<rust::Vec<uint8_t>> {
  static rust::Vec<uint8_t> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arrayBuffer = value.asObject(rt).getArrayBuffer(rt);
    uint8_t* data = arrayBuffer.data(rt);
    size_t size = arrayBuffer.size(rt);
    rust::Vec<uint8_t> vec;
    vec.reserve(size);

    std::copy(data, data + size, std::back_inserter(vec));

    return vec;
  }

  static jsi::Value toJs(jsi::Runtime& rt, const rust::Vec<uint8_t>& vec) {
    auto buffer = std::make_shared<zedmodules::RustVecBuffer>(std::move(vec));
    return jsi::ArrayBuffer(rt, buffer);
  }
};

template <typename T>
struct Bridging<rust::Vec<T>> {
  static rust::Vec<T> fromJs(jsi::Runtime& rt, const jsi::Value &value, std::shared_ptr<CallInvoker> callInvoker) {
    auto arr = value.asObject(rt).asArray(rt);
    size_t len = arr.length(rt);
    rust::Vec<T> vec;
    vec.reserve(len);

    for (size_t i = 0; i < len; i++) {
      auto element = arr.getValueAtIndex(rt, i);
      vec.push_back(react::bridging::fromJs<T>(rt, element, callInvoker));
    }

    return vec;
  }

  static jsi::Array toJs(jsi::Runtime& rt, const rust::Vec<T>& vec) {
    auto arr = jsi::Array(rt, vec.size());

    for (size_t i = 0; i < vec.size(); i++) {
      auto jsElement = react::bridging::toJs(rt, vec[i]);
      arr.setValueAtIndex(rt, i, jsElement);
    }

    return arr;
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::NullableString> {
  static craby::zedmodules::bridging::NullableString fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    if (value.isNull() || value.isUndefined()) {
      return craby::zedmodules::bridging::NullableString{true, rust::String()};
    }

    auto val = react::bridging::fromJs<rust::String>(rt, value, callInvoker);
    auto ret = craby::zedmodules::bridging::NullableString{false, val};

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::NullableString value) {
    if (value.null) {
      return jsi::Value::null();
    }

    return react::bridging::toJs(rt, value.val);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::AcpThreadsChangedEvent> {
  static craby::zedmodules::bridging::AcpThreadsChangedEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$threads = obj.getProperty(rt, "threads");

    auto _obj$threads = react::bridging::fromJs<rust::String>(rt, obj$threads, callInvoker);

    craby::zedmodules::bridging::AcpThreadsChangedEvent ret = {
      _obj$threads
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::AcpThreadsChangedEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$threads = react::bridging::toJs(rt, value.threads);

    obj.setProperty(rt, "threads", _obj$threads);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::AgentConnectedEvent> {
  static craby::zedmodules::bridging::AgentConnectedEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$agentType = obj.getProperty(rt, "agentType");
    auto obj$sessionId = obj.getProperty(rt, "sessionId");

    auto _obj$agentType = react::bridging::fromJs<rust::String>(rt, obj$agentType, callInvoker);
    auto _obj$sessionId = react::bridging::fromJs<rust::String>(rt, obj$sessionId, callInvoker);

    craby::zedmodules::bridging::AgentConnectedEvent ret = {
      _obj$agentType,
      _obj$sessionId
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::AgentConnectedEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$agentType = react::bridging::toJs(rt, value.agent_type);
    auto _obj$sessionId = react::bridging::toJs(rt, value.session_id);

    obj.setProperty(rt, "agentType", _obj$agentType);
    obj.setProperty(rt, "sessionId", _obj$sessionId);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::AgentDisconnectedEvent> {
  static craby::zedmodules::bridging::AgentDisconnectedEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$agentType = obj.getProperty(rt, "agentType");
    auto obj$reason = obj.getProperty(rt, "reason");

    auto _obj$agentType = react::bridging::fromJs<rust::String>(rt, obj$agentType, callInvoker);
    auto _obj$reason = react::bridging::fromJs<rust::String>(rt, obj$reason, callInvoker);

    craby::zedmodules::bridging::AgentDisconnectedEvent ret = {
      _obj$agentType,
      _obj$reason
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::AgentDisconnectedEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$agentType = react::bridging::toJs(rt, value.agent_type);
    auto _obj$reason = react::bridging::toJs(rt, value.reason);

    obj.setProperty(rt, "agentType", _obj$agentType);
    obj.setProperty(rt, "reason", _obj$reason);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::LLMChunkEvent> {
  static craby::zedmodules::bridging::LLMChunkEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$requestId = obj.getProperty(rt, "requestId");
    auto obj$chunk = obj.getProperty(rt, "chunk");

    auto _obj$requestId = react::bridging::fromJs<double>(rt, obj$requestId, callInvoker);
    auto _obj$chunk = react::bridging::fromJs<rust::String>(rt, obj$chunk, callInvoker);

    craby::zedmodules::bridging::LLMChunkEvent ret = {
      _obj$requestId,
      _obj$chunk
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::LLMChunkEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$requestId = react::bridging::toJs(rt, value.request_id);
    auto _obj$chunk = react::bridging::toJs(rt, value.chunk);

    obj.setProperty(rt, "requestId", _obj$requestId);
    obj.setProperty(rt, "chunk", _obj$chunk);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::LLMDoneEvent> {
  static craby::zedmodules::bridging::LLMDoneEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$requestId = obj.getProperty(rt, "requestId");

    auto _obj$requestId = react::bridging::fromJs<double>(rt, obj$requestId, callInvoker);

    craby::zedmodules::bridging::LLMDoneEvent ret = {
      _obj$requestId
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::LLMDoneEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$requestId = react::bridging::toJs(rt, value.request_id);

    obj.setProperty(rt, "requestId", _obj$requestId);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::LLMErrorEvent> {
  static craby::zedmodules::bridging::LLMErrorEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$requestId = obj.getProperty(rt, "requestId");
    auto obj$error = obj.getProperty(rt, "error");

    auto _obj$requestId = react::bridging::fromJs<double>(rt, obj$requestId, callInvoker);
    auto _obj$error = react::bridging::fromJs<rust::String>(rt, obj$error, callInvoker);

    craby::zedmodules::bridging::LLMErrorEvent ret = {
      _obj$requestId,
      _obj$error
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::LLMErrorEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$requestId = react::bridging::toJs(rt, value.request_id);
    auto _obj$error = react::bridging::toJs(rt, value.error);

    obj.setProperty(rt, "requestId", _obj$requestId);
    obj.setProperty(rt, "error", _obj$error);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::ThreadSnapshotPayload> {
  static craby::zedmodules::bridging::ThreadSnapshotPayload fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$snapshot = obj.getProperty(rt, "snapshot");

    auto _obj$snapshot = react::bridging::fromJs<rust::String>(rt, obj$snapshot, callInvoker);

    craby::zedmodules::bridging::ThreadSnapshotPayload ret = {
      _obj$snapshot
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::ThreadSnapshotPayload value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$snapshot = react::bridging::toJs(rt, value.snapshot);

    obj.setProperty(rt, "snapshot", _obj$snapshot);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::ToolCallEventEvent> {
  static craby::zedmodules::bridging::ToolCallEventEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$event = obj.getProperty(rt, "event");

    auto _obj$event = react::bridging::fromJs<rust::String>(rt, obj$event, callInvoker);

    craby::zedmodules::bridging::ToolCallEventEvent ret = {
      _obj$event
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::ToolCallEventEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$event = react::bridging::toJs(rt, value.event);

    obj.setProperty(rt, "event", _obj$event);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::FontSettings> {
  static craby::zedmodules::bridging::FontSettings fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$uiFontFamily = obj.getProperty(rt, "uiFontFamily");
    auto obj$uiFontSize = obj.getProperty(rt, "uiFontSize");
    auto obj$bufferFontFamily = obj.getProperty(rt, "bufferFontFamily");
    auto obj$bufferFontSize = obj.getProperty(rt, "bufferFontSize");

    auto _obj$uiFontFamily = react::bridging::fromJs<rust::String>(rt, obj$uiFontFamily, callInvoker);
    auto _obj$uiFontSize = react::bridging::fromJs<double>(rt, obj$uiFontSize, callInvoker);
    auto _obj$bufferFontFamily = react::bridging::fromJs<rust::String>(rt, obj$bufferFontFamily, callInvoker);
    auto _obj$bufferFontSize = react::bridging::fromJs<double>(rt, obj$bufferFontSize, callInvoker);

    craby::zedmodules::bridging::FontSettings ret = {
      _obj$uiFontFamily,
      _obj$uiFontSize,
      _obj$bufferFontFamily,
      _obj$bufferFontSize
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::FontSettings value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$uiFontFamily = react::bridging::toJs(rt, value.ui_font_family);
    auto _obj$uiFontSize = react::bridging::toJs(rt, value.ui_font_size);
    auto _obj$bufferFontFamily = react::bridging::toJs(rt, value.buffer_font_family);
    auto _obj$bufferFontSize = react::bridging::toJs(rt, value.buffer_font_size);

    obj.setProperty(rt, "uiFontFamily", _obj$uiFontFamily);
    obj.setProperty(rt, "uiFontSize", _obj$uiFontSize);
    obj.setProperty(rt, "bufferFontFamily", _obj$bufferFontFamily);
    obj.setProperty(rt, "bufferFontSize", _obj$bufferFontSize);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::ThemeColors> {
  static craby::zedmodules::bridging::ThemeColors fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$background = obj.getProperty(rt, "background");
    auto obj$surfaceBackground = obj.getProperty(rt, "surfaceBackground");
    auto obj$elevatedSurfaceBackground = obj.getProperty(rt, "elevatedSurfaceBackground");
    auto obj$panelBackground = obj.getProperty(rt, "panelBackground");
    auto obj$elementBackground = obj.getProperty(rt, "elementBackground");
    auto obj$elementHover = obj.getProperty(rt, "elementHover");
    auto obj$elementActive = obj.getProperty(rt, "elementActive");
    auto obj$elementSelected = obj.getProperty(rt, "elementSelected");
    auto obj$elementDisabled = obj.getProperty(rt, "elementDisabled");
    auto obj$ghostElementBackground = obj.getProperty(rt, "ghostElementBackground");
    auto obj$ghostElementHover = obj.getProperty(rt, "ghostElementHover");
    auto obj$ghostElementActive = obj.getProperty(rt, "ghostElementActive");
    auto obj$ghostElementSelected = obj.getProperty(rt, "ghostElementSelected");
    auto obj$text = obj.getProperty(rt, "text");
    auto obj$textMuted = obj.getProperty(rt, "textMuted");
    auto obj$textPlaceholder = obj.getProperty(rt, "textPlaceholder");
    auto obj$textDisabled = obj.getProperty(rt, "textDisabled");
    auto obj$textAccent = obj.getProperty(rt, "textAccent");
    auto obj$icon = obj.getProperty(rt, "icon");
    auto obj$iconMuted = obj.getProperty(rt, "iconMuted");
    auto obj$iconDisabled = obj.getProperty(rt, "iconDisabled");
    auto obj$iconAccent = obj.getProperty(rt, "iconAccent");
    auto obj$border = obj.getProperty(rt, "border");
    auto obj$borderVariant = obj.getProperty(rt, "borderVariant");
    auto obj$borderFocused = obj.getProperty(rt, "borderFocused");
    auto obj$borderSelected = obj.getProperty(rt, "borderSelected");
    auto obj$borderDisabled = obj.getProperty(rt, "borderDisabled");
    auto obj$tabBarBackground = obj.getProperty(rt, "tabBarBackground");
    auto obj$tabActiveBackground = obj.getProperty(rt, "tabActiveBackground");
    auto obj$tabInactiveBackground = obj.getProperty(rt, "tabInactiveBackground");
    auto obj$statusBarBackground = obj.getProperty(rt, "statusBarBackground");
    auto obj$titleBarBackground = obj.getProperty(rt, "titleBarBackground");
    auto obj$toolbarBackground = obj.getProperty(rt, "toolbarBackground");
    auto obj$scrollbarThumbBackground = obj.getProperty(rt, "scrollbarThumbBackground");

    auto _obj$background = react::bridging::fromJs<rust::String>(rt, obj$background, callInvoker);
    auto _obj$surfaceBackground = react::bridging::fromJs<rust::String>(rt, obj$surfaceBackground, callInvoker);
    auto _obj$elevatedSurfaceBackground = react::bridging::fromJs<rust::String>(rt, obj$elevatedSurfaceBackground, callInvoker);
    auto _obj$panelBackground = react::bridging::fromJs<rust::String>(rt, obj$panelBackground, callInvoker);
    auto _obj$elementBackground = react::bridging::fromJs<rust::String>(rt, obj$elementBackground, callInvoker);
    auto _obj$elementHover = react::bridging::fromJs<rust::String>(rt, obj$elementHover, callInvoker);
    auto _obj$elementActive = react::bridging::fromJs<rust::String>(rt, obj$elementActive, callInvoker);
    auto _obj$elementSelected = react::bridging::fromJs<rust::String>(rt, obj$elementSelected, callInvoker);
    auto _obj$elementDisabled = react::bridging::fromJs<rust::String>(rt, obj$elementDisabled, callInvoker);
    auto _obj$ghostElementBackground = react::bridging::fromJs<rust::String>(rt, obj$ghostElementBackground, callInvoker);
    auto _obj$ghostElementHover = react::bridging::fromJs<rust::String>(rt, obj$ghostElementHover, callInvoker);
    auto _obj$ghostElementActive = react::bridging::fromJs<rust::String>(rt, obj$ghostElementActive, callInvoker);
    auto _obj$ghostElementSelected = react::bridging::fromJs<rust::String>(rt, obj$ghostElementSelected, callInvoker);
    auto _obj$text = react::bridging::fromJs<rust::String>(rt, obj$text, callInvoker);
    auto _obj$textMuted = react::bridging::fromJs<rust::String>(rt, obj$textMuted, callInvoker);
    auto _obj$textPlaceholder = react::bridging::fromJs<rust::String>(rt, obj$textPlaceholder, callInvoker);
    auto _obj$textDisabled = react::bridging::fromJs<rust::String>(rt, obj$textDisabled, callInvoker);
    auto _obj$textAccent = react::bridging::fromJs<rust::String>(rt, obj$textAccent, callInvoker);
    auto _obj$icon = react::bridging::fromJs<rust::String>(rt, obj$icon, callInvoker);
    auto _obj$iconMuted = react::bridging::fromJs<rust::String>(rt, obj$iconMuted, callInvoker);
    auto _obj$iconDisabled = react::bridging::fromJs<rust::String>(rt, obj$iconDisabled, callInvoker);
    auto _obj$iconAccent = react::bridging::fromJs<rust::String>(rt, obj$iconAccent, callInvoker);
    auto _obj$border = react::bridging::fromJs<rust::String>(rt, obj$border, callInvoker);
    auto _obj$borderVariant = react::bridging::fromJs<rust::String>(rt, obj$borderVariant, callInvoker);
    auto _obj$borderFocused = react::bridging::fromJs<rust::String>(rt, obj$borderFocused, callInvoker);
    auto _obj$borderSelected = react::bridging::fromJs<rust::String>(rt, obj$borderSelected, callInvoker);
    auto _obj$borderDisabled = react::bridging::fromJs<rust::String>(rt, obj$borderDisabled, callInvoker);
    auto _obj$tabBarBackground = react::bridging::fromJs<rust::String>(rt, obj$tabBarBackground, callInvoker);
    auto _obj$tabActiveBackground = react::bridging::fromJs<rust::String>(rt, obj$tabActiveBackground, callInvoker);
    auto _obj$tabInactiveBackground = react::bridging::fromJs<rust::String>(rt, obj$tabInactiveBackground, callInvoker);
    auto _obj$statusBarBackground = react::bridging::fromJs<rust::String>(rt, obj$statusBarBackground, callInvoker);
    auto _obj$titleBarBackground = react::bridging::fromJs<rust::String>(rt, obj$titleBarBackground, callInvoker);
    auto _obj$toolbarBackground = react::bridging::fromJs<rust::String>(rt, obj$toolbarBackground, callInvoker);
    auto _obj$scrollbarThumbBackground = react::bridging::fromJs<rust::String>(rt, obj$scrollbarThumbBackground, callInvoker);

    craby::zedmodules::bridging::ThemeColors ret = {
      _obj$background,
      _obj$surfaceBackground,
      _obj$elevatedSurfaceBackground,
      _obj$panelBackground,
      _obj$elementBackground,
      _obj$elementHover,
      _obj$elementActive,
      _obj$elementSelected,
      _obj$elementDisabled,
      _obj$ghostElementBackground,
      _obj$ghostElementHover,
      _obj$ghostElementActive,
      _obj$ghostElementSelected,
      _obj$text,
      _obj$textMuted,
      _obj$textPlaceholder,
      _obj$textDisabled,
      _obj$textAccent,
      _obj$icon,
      _obj$iconMuted,
      _obj$iconDisabled,
      _obj$iconAccent,
      _obj$border,
      _obj$borderVariant,
      _obj$borderFocused,
      _obj$borderSelected,
      _obj$borderDisabled,
      _obj$tabBarBackground,
      _obj$tabActiveBackground,
      _obj$tabInactiveBackground,
      _obj$statusBarBackground,
      _obj$titleBarBackground,
      _obj$toolbarBackground,
      _obj$scrollbarThumbBackground
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::ThemeColors value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$background = react::bridging::toJs(rt, value.background);
    auto _obj$surfaceBackground = react::bridging::toJs(rt, value.surface_background);
    auto _obj$elevatedSurfaceBackground = react::bridging::toJs(rt, value.elevated_surface_background);
    auto _obj$panelBackground = react::bridging::toJs(rt, value.panel_background);
    auto _obj$elementBackground = react::bridging::toJs(rt, value.element_background);
    auto _obj$elementHover = react::bridging::toJs(rt, value.element_hover);
    auto _obj$elementActive = react::bridging::toJs(rt, value.element_active);
    auto _obj$elementSelected = react::bridging::toJs(rt, value.element_selected);
    auto _obj$elementDisabled = react::bridging::toJs(rt, value.element_disabled);
    auto _obj$ghostElementBackground = react::bridging::toJs(rt, value.ghost_element_background);
    auto _obj$ghostElementHover = react::bridging::toJs(rt, value.ghost_element_hover);
    auto _obj$ghostElementActive = react::bridging::toJs(rt, value.ghost_element_active);
    auto _obj$ghostElementSelected = react::bridging::toJs(rt, value.ghost_element_selected);
    auto _obj$text = react::bridging::toJs(rt, value.text);
    auto _obj$textMuted = react::bridging::toJs(rt, value.text_muted);
    auto _obj$textPlaceholder = react::bridging::toJs(rt, value.text_placeholder);
    auto _obj$textDisabled = react::bridging::toJs(rt, value.text_disabled);
    auto _obj$textAccent = react::bridging::toJs(rt, value.text_accent);
    auto _obj$icon = react::bridging::toJs(rt, value.icon);
    auto _obj$iconMuted = react::bridging::toJs(rt, value.icon_muted);
    auto _obj$iconDisabled = react::bridging::toJs(rt, value.icon_disabled);
    auto _obj$iconAccent = react::bridging::toJs(rt, value.icon_accent);
    auto _obj$border = react::bridging::toJs(rt, value.border);
    auto _obj$borderVariant = react::bridging::toJs(rt, value.border_variant);
    auto _obj$borderFocused = react::bridging::toJs(rt, value.border_focused);
    auto _obj$borderSelected = react::bridging::toJs(rt, value.border_selected);
    auto _obj$borderDisabled = react::bridging::toJs(rt, value.border_disabled);
    auto _obj$tabBarBackground = react::bridging::toJs(rt, value.tab_bar_background);
    auto _obj$tabActiveBackground = react::bridging::toJs(rt, value.tab_active_background);
    auto _obj$tabInactiveBackground = react::bridging::toJs(rt, value.tab_inactive_background);
    auto _obj$statusBarBackground = react::bridging::toJs(rt, value.status_bar_background);
    auto _obj$titleBarBackground = react::bridging::toJs(rt, value.title_bar_background);
    auto _obj$toolbarBackground = react::bridging::toJs(rt, value.toolbar_background);
    auto _obj$scrollbarThumbBackground = react::bridging::toJs(rt, value.scrollbar_thumb_background);

    obj.setProperty(rt, "background", _obj$background);
    obj.setProperty(rt, "surfaceBackground", _obj$surfaceBackground);
    obj.setProperty(rt, "elevatedSurfaceBackground", _obj$elevatedSurfaceBackground);
    obj.setProperty(rt, "panelBackground", _obj$panelBackground);
    obj.setProperty(rt, "elementBackground", _obj$elementBackground);
    obj.setProperty(rt, "elementHover", _obj$elementHover);
    obj.setProperty(rt, "elementActive", _obj$elementActive);
    obj.setProperty(rt, "elementSelected", _obj$elementSelected);
    obj.setProperty(rt, "elementDisabled", _obj$elementDisabled);
    obj.setProperty(rt, "ghostElementBackground", _obj$ghostElementBackground);
    obj.setProperty(rt, "ghostElementHover", _obj$ghostElementHover);
    obj.setProperty(rt, "ghostElementActive", _obj$ghostElementActive);
    obj.setProperty(rt, "ghostElementSelected", _obj$ghostElementSelected);
    obj.setProperty(rt, "text", _obj$text);
    obj.setProperty(rt, "textMuted", _obj$textMuted);
    obj.setProperty(rt, "textPlaceholder", _obj$textPlaceholder);
    obj.setProperty(rt, "textDisabled", _obj$textDisabled);
    obj.setProperty(rt, "textAccent", _obj$textAccent);
    obj.setProperty(rt, "icon", _obj$icon);
    obj.setProperty(rt, "iconMuted", _obj$iconMuted);
    obj.setProperty(rt, "iconDisabled", _obj$iconDisabled);
    obj.setProperty(rt, "iconAccent", _obj$iconAccent);
    obj.setProperty(rt, "border", _obj$border);
    obj.setProperty(rt, "borderVariant", _obj$borderVariant);
    obj.setProperty(rt, "borderFocused", _obj$borderFocused);
    obj.setProperty(rt, "borderSelected", _obj$borderSelected);
    obj.setProperty(rt, "borderDisabled", _obj$borderDisabled);
    obj.setProperty(rt, "tabBarBackground", _obj$tabBarBackground);
    obj.setProperty(rt, "tabActiveBackground", _obj$tabActiveBackground);
    obj.setProperty(rt, "tabInactiveBackground", _obj$tabInactiveBackground);
    obj.setProperty(rt, "statusBarBackground", _obj$statusBarBackground);
    obj.setProperty(rt, "titleBarBackground", _obj$titleBarBackground);
    obj.setProperty(rt, "toolbarBackground", _obj$toolbarBackground);
    obj.setProperty(rt, "scrollbarThumbBackground", _obj$scrollbarThumbBackground);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::ThemeData> {
  static craby::zedmodules::bridging::ThemeData fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$name = obj.getProperty(rt, "name");
    auto obj$appearance = obj.getProperty(rt, "appearance");
    auto obj$colors = obj.getProperty(rt, "colors");
    auto obj$fonts = obj.getProperty(rt, "fonts");

    auto _obj$name = react::bridging::fromJs<rust::String>(rt, obj$name, callInvoker);
    auto _obj$appearance = react::bridging::fromJs<rust::String>(rt, obj$appearance, callInvoker);
    auto _obj$colors = react::bridging::fromJs<craby::zedmodules::bridging::ThemeColors>(rt, obj$colors, callInvoker);
    auto _obj$fonts = react::bridging::fromJs<craby::zedmodules::bridging::FontSettings>(rt, obj$fonts, callInvoker);

    craby::zedmodules::bridging::ThemeData ret = {
      _obj$name,
      _obj$appearance,
      _obj$colors,
      _obj$fonts
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::ThemeData value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$name = react::bridging::toJs(rt, value.name);
    auto _obj$appearance = react::bridging::toJs(rt, value.appearance);
    auto _obj$colors = react::bridging::toJs(rt, value.colors);
    auto _obj$fonts = react::bridging::toJs(rt, value.fonts);

    obj.setProperty(rt, "name", _obj$name);
    obj.setProperty(rt, "appearance", _obj$appearance);
    obj.setProperty(rt, "colors", _obj$colors);
    obj.setProperty(rt, "fonts", _obj$fonts);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::ThemeChangedEvent> {
  static craby::zedmodules::bridging::ThemeChangedEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$theme = obj.getProperty(rt, "theme");

    auto _obj$theme = react::bridging::fromJs<craby::zedmodules::bridging::ThemeData>(rt, obj$theme, callInvoker);

    craby::zedmodules::bridging::ThemeChangedEvent ret = {
      _obj$theme
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::ThemeChangedEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$theme = react::bridging::toJs(rt, value.theme);

    obj.setProperty(rt, "theme", _obj$theme);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::WorkspaceInfo> {
  static craby::zedmodules::bridging::WorkspaceInfo fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$projectName = obj.getProperty(rt, "projectName");
    auto obj$rootPath = obj.getProperty(rt, "rootPath");
    auto obj$currentFilePath = obj.getProperty(rt, "currentFilePath");

    auto _obj$projectName = react::bridging::fromJs<craby::zedmodules::bridging::NullableString>(rt, obj$projectName, callInvoker);
    auto _obj$rootPath = react::bridging::fromJs<craby::zedmodules::bridging::NullableString>(rt, obj$rootPath, callInvoker);
    auto _obj$currentFilePath = react::bridging::fromJs<craby::zedmodules::bridging::NullableString>(rt, obj$currentFilePath, callInvoker);

    craby::zedmodules::bridging::WorkspaceInfo ret = {
      _obj$projectName,
      _obj$rootPath,
      _obj$currentFilePath
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::WorkspaceInfo value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$projectName = react::bridging::toJs(rt, value.project_name);
    auto _obj$rootPath = react::bridging::toJs(rt, value.root_path);
    auto _obj$currentFilePath = react::bridging::toJs(rt, value.current_file_path);

    obj.setProperty(rt, "projectName", _obj$projectName);
    obj.setProperty(rt, "rootPath", _obj$rootPath);
    obj.setProperty(rt, "currentFilePath", _obj$currentFilePath);

    return jsi::Value(rt, obj);
  }
};

template <>
struct Bridging<craby::zedmodules::bridging::WorkspaceChangedEvent> {
  static craby::zedmodules::bridging::WorkspaceChangedEvent fromJs(jsi::Runtime &rt, const jsi::Value& value, std::shared_ptr<CallInvoker> callInvoker) {
    auto obj = value.asObject(rt);
    auto obj$workspace = obj.getProperty(rt, "workspace");

    auto _obj$workspace = react::bridging::fromJs<craby::zedmodules::bridging::WorkspaceInfo>(rt, obj$workspace, callInvoker);

    craby::zedmodules::bridging::WorkspaceChangedEvent ret = {
      _obj$workspace
    };

    return ret;
  }

  static jsi::Value toJs(jsi::Runtime &rt, craby::zedmodules::bridging::WorkspaceChangedEvent value) {
    jsi::Object obj = jsi::Object(rt);
    auto _obj$workspace = react::bridging::toJs(rt, value.workspace);

    obj.setProperty(rt, "workspace", _obj$workspace);

    return jsi::Value(rt, obj);
  }
};

} // namespace react
} // namespace facebook
