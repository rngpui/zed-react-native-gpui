// Auto generated by Craby. DO NOT EDIT.
#include "CxxZedWorkspaceModule.hpp"
#include "cxx.h"
#include "bridging-generated.hpp"
#include <react/bridging/Bridging.h>

using namespace facebook;

namespace craby {
namespace zedmodules {
namespace modules {

std::string CxxZedWorkspaceModule::dataPath = std::string();

CxxZedWorkspaceModule::CxxZedWorkspaceModule(
    std::shared_ptr<react::CallInvoker> jsInvoker)
    : TurboModule(CxxZedWorkspaceModule::kModuleName, jsInvoker) {
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::zedmodules::signals::SignalManager::getInstance();
  manager.registerDelegate(id,
    [this](const std::string& name, void* signal) {
      this->emit(name, reinterpret_cast<bridging::ZedWorkspaceSignal*>(signal));
    }
  );
  callInvoker_ = std::move(jsInvoker);
  module_ = std::shared_ptr<craby::zedmodules::bridging::ZedWorkspace>(
    craby::zedmodules::bridging::createZedWorkspace(
      reinterpret_cast<uintptr_t>(this),
      rust::Str(dataPath.data(), dataPath.size())).into_raw(),
    [](craby::zedmodules::bridging::ZedWorkspace *ptr) { rust::Box<craby::zedmodules::bridging::ZedWorkspace>::from_raw(ptr); }
  );
  threadPool_ = std::make_shared<craby::zedmodules::utils::ThreadPool>(10);
  methodMap_["addListener"] = MethodMetadata{1, &CxxZedWorkspaceModule::addListener};
  methodMap_["getWorkspaceInfo"] = MethodMetadata{0, &CxxZedWorkspaceModule::getWorkspaceInfo};
  methodMap_["removeListeners"] = MethodMetadata{1, &CxxZedWorkspaceModule::removeListeners};
  methodMap_["workspaceChanged"] = MethodMetadata{1, &CxxZedWorkspaceModule::workspaceChanged};
}

CxxZedWorkspaceModule::~CxxZedWorkspaceModule() {
  invalidate();
}

void CxxZedWorkspaceModule::invalidate() {
  if (invalidated_.exchange(true)) {
    return;
  }

  invalidated_.store(true);
  listenersMap_.clear();

  // Unregister from signal manager
  uintptr_t id = reinterpret_cast<uintptr_t>(this);
  auto& manager = craby::zedmodules::signals::SignalManager::getInstance();
  manager.unregisterDelegate(id);

  // Shutdown thread pool
  threadPool_->shutdown();
}

void CxxZedWorkspaceModule::emit(std::string name, bridging::ZedWorkspaceSignal* signal) {
  std::vector<std::shared_ptr<facebook::jsi::Function>> listeners;
  {
    std::lock_guard<std::mutex> lock(listenersMutex_);
    auto it = listenersMap_.find(name);
    if (it != listenersMap_.end()) {
      for (auto &[_, listener] : it->second) {
        listeners.push_back(listener);
      }
    }
  }

  // Prepare payload: extract from signal or use undefined
  auto payloadPtr = std::make_shared<facebook::jsi::Value>();
  
  if (signal == nullptr) {
    *payloadPtr = facebook::jsi::Value::undefined();
  } else {
    // Use shared_ptr to manage signal lifetime across async callbacks
    auto signalPtr = std::shared_ptr<bridging::ZedWorkspaceSignal>(
      signal,
      [](bridging::ZedWorkspaceSignal* ptr) {
        // Use Rust FFI function to drop signal memory
        if (ptr != nullptr) {
          craby::zedmodules::bridging::drop_zed_workspace_signal(ptr);
        }
      }
    );

    // Extract payload using FFI function and convert to jsi::Value
    // We'll need to capture signalPtr in the lambda
    for (auto& listener : listeners) {
      try {
        callInvoker_->invokeAsync([listener, signalPtr, name](jsi::Runtime &rt) {
          jsi::Value data = jsi::Value::undefined();
          if (name == "workspaceChanged") {
            auto payload = craby::zedmodules::bridging::get_workspace_changed_payload(*signalPtr);
            data = react::bridging::toJs(rt, payload);
          }
          listener->call(rt, data);
        });
      } catch (const std::exception& err) {
        // Noop
      }
    }
    return;
  }

  for (auto& listener : listeners) {
    try {
      callInvoker_->invokeAsync([listener, payloadPtr](jsi::Runtime &rt) {
        try {
          listener->call(rt, *payloadPtr);
        } catch (const jsi::JSError &err) {
          throw err;
        } catch (const std::exception &err) {
          throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
        }
      });
    } catch (const std::exception& err) {
      // Noop
    }
  }
}

jsi::Value CxxZedWorkspaceModule::addListener(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedWorkspaceModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0$raw = args[0].asString(rt).utf8(rt);
    auto arg0 = rust::Str(arg0$raw.data(), arg0$raw.size());
    craby::zedmodules::bridging::addListener(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedWorkspaceModule::getWorkspaceInfo(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedWorkspaceModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (0 != count) {
      throw jsi::JSError(rt, "Expected 0 argument");
    }

    auto ret = craby::zedmodules::bridging::getWorkspaceInfo(*it_);

    return react::bridging::toJs(rt, ret);
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedWorkspaceModule::removeListeners(jsi::Runtime &rt,
                                react::TurboModule &turboModule,
                                const jsi::Value args[],
                                size_t count) {
  auto &thisModule = static_cast<CxxZedWorkspaceModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto arg0 = react::bridging::fromJs<double>(rt, args[0], callInvoker);
    craby::zedmodules::bridging::removeListeners(*it_, arg0);

    return jsi::Value::undefined();
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

jsi::Value CxxZedWorkspaceModule::workspaceChanged(jsi::Runtime &rt,
                      react::TurboModule &turboModule,
                      const jsi::Value args[],
                      size_t count) {
  auto &thisModule = static_cast<CxxZedWorkspaceModule &>(turboModule);
  auto callInvoker = thisModule.callInvoker_;
  auto it_ = thisModule.module_;

  try {
    if (1 != count) {
      throw jsi::JSError(rt, "Expected 1 argument");
    }

    auto callback = args[0].asObject(rt).asFunction(rt);
    auto callbackRef = std::make_shared<jsi::Function>(std::move(callback));
    auto id = thisModule.nextListenerId_.fetch_add(1);
    auto name = "workspaceChanged";

    if (thisModule.listenersMap_.find(name) == thisModule.listenersMap_.end()) {
      thisModule.listenersMap_[name] = std::unordered_map<size_t, std::shared_ptr<facebook::jsi::Function>>();
    }

    {
      std::lock_guard<std::mutex> lock(thisModule.listenersMutex_);
      thisModule.listenersMap_[name].emplace(id, callbackRef);
    }

    auto modulePtr = &thisModule;
    auto cleanup = [modulePtr, name, id] {
      std::lock_guard<std::mutex> lock(modulePtr->listenersMutex_);
      auto eventMap = modulePtr->listenersMap_.find(name);
      if (eventMap != modulePtr->listenersMap_.end()) {
        auto it = eventMap->second.find(id);
        if (it != eventMap->second.end()) {
          eventMap->second.erase(it);
        }
      }
      return jsi::Value::undefined();
    };

    return jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "cleanup"),
      0,
      [cleanup](jsi::Runtime& rt, const jsi::Value&, const jsi::Value*, size_t) -> jsi::Value {
        return cleanup();
      }
    );
  } catch (const jsi::JSError &err) {
    throw err;
  } catch (const std::exception &err) {
    throw jsi::JSError(rt, craby::zedmodules::utils::errorMessage(err));
  }
}

} // namespace modules
} // namespace zedmodules
} // namespace craby
